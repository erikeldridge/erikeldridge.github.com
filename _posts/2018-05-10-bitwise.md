---
title: Bitwise
layout: post
date: 2018-05-10 00:08:01 -0700
tags:
- toolkit
- java
- javascript
---
## Context

I had a legacy identifier (ID). The ID is a 64 bit, unsigned, numeric, base64-encoded value. The first four bits are 1010. The last 60 are random. My reference implementation is JavaScript (JS). I need to generate these IDs in Java.

I rarely have to think about bitwise operations, so this problem started out frustrating, but I developed an appreciation for the elegance of binary, hex and bitwise operations as I warmed up, and was reluctant to trade them in for the self-documenting Java syntax at the end.

## JS

JS doesn't have 64 bit numbers, so we use an [array of 8-bit, unsigned ints](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int8Array):

    var ints = new Uint8Array(8)

We can populate this array with random values:

    window.crypto.getRandomValues(ints)

We can get the last (random) 4 bits of the first byte using the AND operator against 1111 (0xF in hex):

    var rand = 0xF & ints[0]

We can prepend 1010 by adding 10100000 (0xA0 in hex):

    ints[0] = 0xA0 + rand

We can convert this to an array of chars and then base64 encode:

    btoa(String.fromCharCode(...ints))

Sanity:

    atob("m125LI0gXGc=").split('').map(c=>console.log(c.charCodeAt(0)))

## Java

Java makes this easier with native 64 bit long, byte primitives and a nice Random util.

Generate a random long within a range 1010...:

    import java.util.Random;
    Random r = new Random()
    long id = r.longs(0xA0000000, 0xB0000000).limit(1).findFirst().getAsLong()

Note: [javarepl](http://www.javarepl.com/) makes it easy to hack around.

Convert to bytes:

    byte[] bytes = String.valueOf(id).getBytes()

Encode:

    Base64.getEncoder().encodeToString(bytes)

Sanity:

    Long.toHexString(id)
    Long.toBinaryString(id)